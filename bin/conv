#!/usr/bin/env node
var path = require("path");
process.env['NODE_CONFIG_DIR'] = path.join(__dirname, "..", "config");
var gitdir = path.join(__dirname, "..", ".git");

var http = require("https");
var releaseUrl = {
  hostname: 'api.github.com',
	path: '/repos/kdsoo/mediaconverter/releases/latest',
  headers: { 'User-Agent': 'Mozilla/5.0' }
};

var spawn = require("child_process").spawn;
var spawnSync = require("child_process").spawnSync;
var fs = require('fs');
var path = require("path");
var rl = require("readline");
var progress = require("progress");
var config = require("config");

// check version upgrade
updateVersion();


var source_formats = config.get("source.mediaformat");
var target_w = config.get("target.resolution.width");
var target_h = config.get("target.resolution.height");
var target_br = config.get("target.bitrate");
var target_name_tail = config.get("target.filename_tail");
var target_name_ext = config.get("target.mediaformat");		// file type to be converted

if (process.argv.length !== 3) {
	console.error(process.argv.length, process.argv);
	process.exit(1)
}
var arg = process.argv[2]
var inputDir;
var fileList = [];
var totalFiles = 0;
if (arg === ".") {
	inputDir = process.cwd();
} else {
	inputDir = arg;
}

console.log("Media file repository:", inputDir);
var files = fs.readdirSync(inputDir);
for (var i = 0; i < files.length; i ++) {
	if (isMediaFile(files[i])) {
		// var file = {filename:filename, duration: duration, convres: convres};
		var meta = getVideoMeta(files[i]);
		var filename = path.join(inputDir, files[i]);
		var duration = meta.duration * 1000000;
		var bitrate = meta.bit_rate;	// TODO: don't convert video with less than target.bitrate
		var convres = false;
		if (meta.width > target_w && meta.height > target_h) {
			convres = true;
			var file = {filename: filename, duration: duration, convres: convres};
			fileList.push(file);
			++totalFiles;
		} else if (bitrate > target_br * 1.5) {
			var file = {filename: filename, duration: duration, convres: convres};
			fileList.push(file);
			++totalFiles;
		} else {
			console.error(filename, "with resolution", meta.width, meta.height
				, "and bitrate", bitrate, "no need to be converted");
		}
	}
}
console.log("Media files to be converted:", fileList);

if (fileList.length > 0) {
	runSeries(fileList, function(err) {
		if (err) {
			console.error(err);
		}
	});
}

function getVideoMeta(file, cb) {
	var options = ["-v", "error", "-select_streams", "v:0", "-show_entries", "stream=width,height,bit_rate,duration", "-of", "json", file];
	var getres = spawnSync("ffprobe", options);
	var meta = getres.stdout.toString();
	meta = JSON.parse(meta);
	meta = meta.streams[0];
	return meta;
}

function processVideo(file, duration, convres, cb) {
	var options;
	var namearr = file.split(".");
	namearr[namearr.length -2] = namearr[namearr.length - 2] + target_name_tail;
	namearr[namearr.length -1] = target_name_ext;
	var output = namearr.join(".");
	if (convres) {
		options = ["-i", file, "-vf", "scale=" + target_w + ":" + target_h, "-b:v", target_br, "-progress", "-", output];
	} else {
		options = ["-i", file, "-b:v", target_br, "-progress", "-", output];
	}

	if (fs.existsSync(output)) {
		console.error(output, "already exists. Removing it");
		fs.unlinkSync(output);
	}

	var conv = spawn("ffmpeg", options);
	var progressTotal = 100;
	var barTick = 0;
	var bar = new progress('  :title [:bar] :percent :etas', {
		complete: '=', incomplete: ' ', width: 100, total: progressTotal
	});
	var line = rl.createInterface({input: conv.stdout});
	line.on("line", function(l) {
		if (l.search("out_time_ms=") > -1) {
			var out_time_ms = Number(l.split("=")[1]);
			while (barTick/progressTotal < out_time_ms/duration) {
				bar.tick(1, {title: file});
				++barTick;
			}
		}
	});

	conv.stderr.on("data", function(data) {
		// console.error("convert error:", data.toString());
	});
	conv.stdout.on("data", function(data) {
		//console.log("convert data:", data.toString());
		// out_time_ms=15046531 => out_time = out_time_ms/1000000
		// elapsed time % = (out_time / duration) * 100
	});
	conv.stdout.on("end", function() {
	});
	conv.on('exit', function(code){
		line.close();
		console.log(file, "conversion done with:", code);
		--totalFiles;
		if (totalFiles == 0) {
			console.log("#############################################");
			console.log("All files converted");
			console.log("#############################################");
		}
		if (cb) cb(true);
	});
}

function isMediaFile(name) {
	var ret = false;
	var extList = source_formats;
	// .toUpperCase()
	var nameSplit = name.split(".");
	var extension = nameSplit[nameSplit.length -1];
	if (extList.indexOf(extension.toLowerCase()) > -1) {
		ret = true;
	}
	if (name.includes(target_name_tail + "." + target_name_ext)) {
		ret = false;
	};
	return ret;
}

function runSeries(fileMetaList, cb){
	var runNext = function(){
		var file = fileMetaList.shift();
		processVideo(file.filename, file.duration, file.convres, function(ret){
			if (ret) {
				if (fileMetaList.length) runNext();
				else cb(null);
			}
		});
	};
	runNext();
};

function msToTime(duration) {
	duration = duration / 1000;
	var milliseconds = parseInt((duration%1000)/100)
		, seconds = parseInt((duration/1000)%60)
		, minutes = parseInt((duration/(1000*60))%60)
		, hours = parseInt((duration/(1000*60*60))%24);

	hours = (hours < 10) ? "0" + hours : hours;
	minutes = (minutes < 10) ? "0" + minutes : minutes;
	seconds = (seconds < 10) ? "0" + seconds : seconds;

	return hours + ":" + minutes + ":" + seconds + "." + milliseconds;
}


function gitPull(callback) {
	var child = spawn('git', ['--git-dir', gitdir, 'pull']);
	var log = ""
	child.stderr.on('data', function(data) {
		console.log('err data: ' + data);
	});

	child.stdout.on('data', function(data) {
		log += data;
		console.log('stdout: ' + data);
	});
	child.on('exit', function(code){
		console.log('exit: ' + code);
		callback(code, log);
	});

};

function gitCheckout(head, callback) {
	var child = spawn('git', ['--git-dir', gitdir, 'checkout', head]);
	var log = "";

	child.stderr.on('data', function(data) {
		//console.log('err data: ' + data);
	});

	child.stdout.on('data', function(data) {
		log += data;
		console.log('stdout: ' + data);
	});
	child.on('exit', function(code){
		callback(code, log);
	});
};

function getReleaseMeta(url, cb) {
	var req = http.get(url, function(res) {
		console.log('statusCode:', res.statusCode);
		var json = "";

		res.on("data", function(data) {
			json += data;
		});
		res.on("end", function(){
			try {
				json = JSON.parse(json);
			} catch(e) {
				console.error(e);
			}
			cb(res.statusCode, json);
		});
	});
}

function getCurrentVersion() {
	var getTag = spawnSync("git", ["--git-dir", gitdir, "describe", "--tags", "--abbrev=0"]);
	var tag = getTag.stdout.toString().trim();
	return tag;
}

function needUpdate(remote_tag) {
	var needUpdate = false;
	var tag = getCurrentVersion();
	if (remote_tag !== tag) {
		needUpdate = true;
	} else console.log("Your mediaconverter is up to date");
	console.log("need update?", needUpdate, "(", remote_tag, ",", tag, ")");
	return needUpdate;
}

function updateVersion() {
	getReleaseMeta(releaseUrl, function(code, meta) {
		if (code === 200) {
			if (needUpdate(meta.tag_name)) {
				gitCheckout("master", function(code, data) {
					if (code === 0) {
						gitPull(function(code, ret) {
							console.log("git pull ended with:", code, ret);
							if (code === 0) {
								gitCheckout(meta.tag_name, function(code, data) {
									console.log("git checkout to", meta.tag_name
												, "ended with", code);
									process.exit();
								});
							} else {
								console.error("git pull error:", code);
								process.exit();
							}
						});
					} else {
						console.error("git checkout master failed with", code);
						process.exit();
					}
				});
			}
		} else {
			console.error(code, "get meta error");
			process.exit();
		}
	});
}

